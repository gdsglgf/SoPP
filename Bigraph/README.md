课程设计提交的版本：Bigraph - 1st

结果来源：将所有搜索结果写入到缓存文件中，搜索完成后，从缓存文件中查找最大的匹配值，然后根据匹配值再次搜索缓存文件，将符合的结果写入到输出文件中。

效率分析：对文件处理了3次，一次是写搜索结果，一次是读缓存文件查找最大匹配值，一次是读缓存文件选出结果集。

特点：保留全部搜索结果，可以追溯程序的执行过程，验证程序的正确性。

改进方案：
1>如果保留缓存文件，可以将后两次读缓存文件可以合并成一次完成。具体方法是，搜索缓存文件时，将当前搜索记录中最大的匹配结果写入到输出文件中。更详细一点，就是使用一个变量记录搜索历史记录的最大匹配值，如果当前的匹配值大于变量记录的值，说明当前的搜索结果为新的结果，将此结果写入到输出文件中。如果当前的匹配值等于变量记录的值，说明当前的搜索结果也是结果，将此结果附加到输出文件中。

2>如果不使用缓存文件，可以直接将搜索结果写入到输出文件中。具体方法是，使用一个变量记录搜索历史记录的最大匹配值，如果当前的匹配值大于变量记录的值，说明当前的搜索结果为新的结果，将此结果写入到输出文件中。如果当前的匹配值等于变量记录的值，说明当前的搜索结果也是结果，将此结果附加到输出文件中。


改进版本：Bigraph - 2nd

结果来源：采用Bigraph - 1st版本改进方案中的方案2。

效率分析：将执行3次文件处理合并成1次文件处理，效率明显得以提高。

特点：减少了文件的读写次数，提高了效率。

改进方案：从文件处理方面已经不能够提出改进方案了，只能从搜索的过程下手了。从Bigraph - 1st版本中的缓存文件中可以看出，最终的结果是分散的分布于缓存文件中，这进一步说明结果后面有许多无用的搜索记录。问题来了，能不能减少这些无用的搜索记录，使得程序不必做这些无用功呢？还是可以做到的，只要对接下来的搜索结果进行一下预处理可以了。问题又来了，怎样预处理呢？哦，对了。程序的搜索过程不是“按行搜索”的吗？当搜索到某一行时，搜索结果已经记录下来了，虽说没有完全搜索完。然而，这已经可以大做文章了。可将当前的不完全搜索记录个数加上剩下没有搜索的行数，然后，将所得之和与历史搜索记录的最大匹配值比较，如果前者大与或等于后者，则继续搜索下去。反之，放弃搜索。



改进版本：Bigraph - 3rd

结果来源：采用Bigraph - 2nd版本改进方案中的方案。

效率分析：减少了搜索的次数，从而提高效率。

特点：相比版本Bigraph - 1st，有了很大的改进。无论是从程序的结构，还是从程序的效率方面考虑。


## 比较结果
![](https://github.com/gdsglgf/SoPP/raw/master/Bigraph/result.png)